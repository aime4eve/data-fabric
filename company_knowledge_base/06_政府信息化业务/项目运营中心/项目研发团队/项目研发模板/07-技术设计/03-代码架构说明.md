# 项目结构说明

## 📁 目录结构概览

本项目采用领域驱动设计(DDD)架构，目录结构清晰分层，便于维护和扩展。

```
knowledge-base-app/
├── src/                          # 源代码目录
│   ├── backend/                  # 后端服务
│   │   ├── domain/               # 领域层 - 核心业务逻辑
│   │   ├── application/          # 应用层 - 业务用例协调
│   │   ├── infrastructure/       # 基础设施层 - 技术实现
│   │   ├── presentation/         # 表示层 - API接口
│   │   └── shared_kernel/        # 共享内核 - 通用组件
│   └── frontend/                 # 前端应用
│       ├── application/          # 前端应用层
│       ├── infrastructure/       # 前端基础设施层
│       ├── presentation/         # 前端表示层
│       └── shared/               # 前端共享层
├── tests/                        # 测试目录
├── docs/                         # 文档目录
├── scripts/                      # 脚本工具
├── docker-compose.yml           # Docker服务配置
├── setup_dev_env.sh             # 环境搭建脚本
└── README.md                     # 项目说明文档
```

## 🏗️ 分层架构详解

### 1. 领域层 (Domain Layer)

**位置**: `src/backend/domain/`

**职责**: 包含核心业务逻辑，不依赖任何外部技术实现

**主要组件**:
- **entities/**: 实体定义，具有唯一标识的业务对象
- **value_objects/**: 值对象，描述领域概念的无状态对象
- **aggregates/**: 聚合根，维护业务规则的一致性边界
- **repositories/**: 仓库接口，定义领域对象的持久化契约
- **services/**: 领域服务，处理跨实体的业务逻辑
- **events/**: 领域事件，记录重要的业务事件
- **knowledge/**: 知识管理子域
- **graph/**: 图数据库子域
- **user/**: 用户管理子域

**示例**:
```python
# domain/entities/knowledge.py
class KnowledgeEntity:
    def __init__(self, id: str, title: str, content: str):
        self.id = id
        self.title = title
        self.content = content
        self.created_at = datetime.now()
    
    def update_content(self, new_content: str):
        if len(new_content) < 10:
            raise ValueError("内容长度不能少于10个字符")
        self.content = new_content
```

### 2. 应用层 (Application Layer)

**位置**: `src/backend/application/`

**职责**: 协调领域对象执行特定的业务用例，不包含业务规则

**主要组件**:
- **services/**: 应用服务，协调业务用例的执行
- **dto/**: 数据传输对象，用于层间数据传递
- **commands/**: 命令对象，封装写操作请求
- **queries/**: 查询对象，封装读操作请求
- **handlers/**: 命令/查询处理器
- **mappers/**: 对象映射器，转换不同层间的数据格式

**示例**:
```python
# application/services/knowledge_service.py
class KnowledgeApplicationService:
    def __init__(self, knowledge_repo: KnowledgeRepository):
        self.knowledge_repo = knowledge_repo
    
    def create_knowledge(self, command: CreateKnowledgeCommand):
        knowledge = KnowledgeEntity(
            id=generate_id(),
            title=command.title,
            content=command.content
        )
        self.knowledge_repo.save(knowledge)
        return KnowledgeDTO.from_entity(knowledge)
```

### 3. 基础设施层 (Infrastructure Layer)

**位置**: `src/backend/infrastructure/`

**职责**: 提供技术实现，如数据库访问、外部服务集成等

**主要组件**:
- **persistence/**: 持久化实现
  - **nebula_graph/**: NebulaGraph图数据库实现
  - **redis/**: Redis缓存实现
  - **files/**: 文件存储实现
- **external_services/**: 外部服务集成
  - **ai_services/**: AI服务集成
  - **search/**: 搜索服务集成
  - **notification/**: 通知服务集成
- **repositories/**: 仓库实现
- **messaging/**: 消息传递实现
- **config/**: 配置管理
- **logging/**: 日志管理

**示例**:
```python
# infrastructure/repositories/knowledge_repository.py
class KnowledgeRepositoryImpl(KnowledgeRepository):
    def __init__(self, nebula_client: NebulaClient):
        self.nebula_client = nebula_client
    
    def save(self, knowledge: KnowledgeEntity):
        query = """
        INSERT VERTEX KnowledgeEntity(id, title, content) 
        VALUES '{}':('{}', '{}', '{}')
        """.format(knowledge.id, knowledge.id, knowledge.title, knowledge.content)
        self.nebula_client.execute(query)
    
    def find_by_id(self, id: str) -> Optional[KnowledgeEntity]:
        query = f"FETCH PROP ON KnowledgeEntity '{id}'"
        result = self.nebula_client.execute(query)
        return self._map_to_entity(result)
```

### 4. 表示层 (Presentation Layer)

**位置**: `src/backend/presentation/`

**职责**: 处理用户请求和响应，提供API接口

**主要组件**:
- **rest_api/**: REST API实现
  - **controllers/**: 控制器，处理HTTP请求
  - **middleware/**: 中间件，处理横切关注点
  - **validators/**: 请求验证器
  - **serializers/**: 响应序列化器
  - **routers/**: 路由配置

**示例**:
```python
# presentation/rest_api/controllers/knowledge_controller.py
@api.route('/knowledge')
class KnowledgeController(Resource):
    @api.expect(knowledge_model)
    @api.marshal_with(knowledge_response)
    def post(self):
        """创建知识条目"""
        command = CreateKnowledgeCommand(**api.payload)
        result = knowledge_service.create_knowledge(command)
        return result, 201
```

### 5. 共享内核 (Shared Kernel)

**位置**: `src/backend/shared_kernel/`

**职责**: 提供各层共享的基础组件和工具

**主要组件**:
- **exceptions/**: 通用异常定义
- **utils/**: 工具类和函数
- **constants/**: 常量定义
- **interfaces/**: 共享接口定义

**示例**:
```python
# shared_kernel/exceptions.py
class DomainException(Exception):
    """领域异常基类"""
    pass

class BusinessRuleException(DomainException):
    """业务规则异常"""
    pass

# shared_kernel/utils.py
def generate_id() -> str:
    """生成唯一标识符"""
    return str(uuid.uuid4())
```

## 🎯 前端架构

### 前端分层

**位置**: `src/frontend/`

**主要组件**:
- **application/**: 前端应用层，处理业务逻辑
- **infrastructure/**: 前端基础设施层，处理API调用和存储
- **presentation/**: 前端表示层，React组件和页面
- **shared/**: 前端共享层，工具函数和常量

**示例**:
```typescript
// infrastructure/api_client/knowledge_api.ts
export class KnowledgeAPI {
  async createKnowledge(data: CreateKnowledgeDTO): Promise<Knowledge> {
    const response = await axios.post('/api/knowledge', data);
    return response.data;
  }
}

// presentation/components/KnowledgeForm.tsx
export const KnowledgeForm: React.FC = () => {
  const { createKnowledge } = useKnowledgeService();
  
  const handleSubmit = async (values: KnowledgeFormValues) => {
    await createKnowledge(values);
    message.success('知识条目创建成功');
  };
  
  return (
    <Form onFinish={handleSubmit}>
      <Form.Item name="title" rules={[{ required: true }]}>
        <Input placeholder="请输入标题" />
      </Form.Item>
      <Form.Item name="content" rules={[{ required: true }]}>
        <TextArea placeholder="请输入内容" />
      </Form.Item>
      <Button type="primary" htmlType="submit">
        创建
      </Button>
    </Form>
  );
};
```

## 🧪 测试架构

### 测试分层

**位置**: `tests/`

**主要组件**:
- **unit/**: 单元测试，测试单个组件
- **integration/**: 集成测试，测试组件间的交互
- **e2e/**: 端到端测试，测试完整用户流程

**示例**:
```python
# tests/unit/domain/test_knowledge_entity.py
def test_knowledge_entity_creation():
    knowledge = KnowledgeEntity(
        id="test-123",
        title="测试知识",
        content="这是测试内容"
    )
    assert knowledge.id == "test-123"
    assert knowledge.title == "测试知识"

def test_knowledge_content_validation():
    knowledge = KnowledgeEntity("test-123", "标题", "内容")
    with pytest.raises(ValueError):
        knowledge.update_content("短")  # 少于10个字符应该报错
```

## 📚 文档架构

### 文档分类

**位置**: `docs/`

**主要组件**:
- **api/**: API文档，包含REST和GraphQL文档
- **architecture/**: 架构文档，包含DDD和部署架构
- **deployment/**: 部署文档，包含Docker和Kubernetes配置

## 🔧 脚本工具

### 开发工具

**位置**: `scripts/`

**主要组件**:
- **dev/**: 开发脚本，环境搭建和日常开发
- **build/**: 构建脚本，项目构建和打包
- **deploy/**: 部署脚本，环境部署和发布
- **test/**: 测试脚本，自动化测试执行

## 🚀 快速开始

### 1. 环境搭建

```bash
# 运行一键搭建脚本
./setup_dev_env.sh

# 或者手动搭建
python3 -m venv venv
source venv/bin/activate
pip install -r src/backend/requirements.txt
cd src/frontend && npm install
```

### 2. 启动服务

```bash
# 使用Docker Compose启动所有服务
docker-compose up -d

# 或者分别启动
./start_dev.sh
```

### 3. 访问应用

- **前端应用**: http://localhost:3000
- **后端API**: http://localhost:5000
- **监控面板**: http://localhost:3001
- **数据库管理**: http://localhost:7000

## 📖 开发指南

### 添加新功能

1. **定义领域模型**: 在`domain/`目录下定义实体和值对象
2. **创建应用服务**: 在`application/`目录下创建应用服务
3. **实现基础设施**: 在`infrastructure/`目录下实现技术细节
4. **添加API接口**: 在`presentation/`目录下创建控制器
5. **编写测试**: 在`tests/`目录下添加相应测试

### 代码规范

- **后端**: 使用Black格式化代码，遵循PEP 8规范
- **前端**: 使用Prettier格式化代码，遵循React最佳实践
- **命名**: 使用清晰、描述性的命名，避免缩写
- **注释**: 为复杂业务逻辑添加详细注释

## 🆘 常见问题

### Q: 如何添加新的子域？
A: 在`domain/`、`application/`和`infrastructure/`目录下创建对应的子域目录，遵循相同的分层结构。

### Q: 如何处理跨域请求？
A: 在`presentation/rest_api/middleware/`中添加CORS中间件配置。

### Q: 如何添加新的API端点？
A: 在`presentation/rest_api/controllers/`中创建新的控制器类，并在路由中注册。

### Q: 如何配置数据库连接？
A: 修改`src/backend/.env`文件中的数据库配置参数。

---

**更多详细信息，请参考各目录下的README文件和代码注释。**