# 企业知识库管理系统 - 技术架构文档

## 1. 架构设计

```mermaid
graph TD
    A[用户浏览器] --> B[React前端应用]
    B --> C[Flask后端API]
    C --> D[NebulaGraph图数据库]
    C --> E[Elasticsearch搜索引擎]
    C --> F[Redis缓存]
    C --> G[文件存储系统]
    C --> J[PostgreSQL数据库]
    
    subgraph 前端层
        B
    end
    
    subgraph 后端服务层
        C
        F
    end
    
    subgraph 数据存储层
        D
        E
        G
        J
    end
    
    subgraph 外部服务
        H[文档解析服务]
        I[知识图谱计算服务]
    end
    
    C -.-> H
    C -.-> I

```

## 2. 技术描述

* **前端**: React\@18 + TypeScript\@5 + Vite\@5 + Ant Design\@5 + Tailwind CSS\@3 + React Query\@4

* **后端**: Flask\@3.0 + Flask-RESTX + Python\@3.11 + Celery\@5 + NetworkX + igraph + SQLAlchemy\@2.0

* **关系数据库**: PostgreSQL\@15

* **图数据库**: NebulaGraph\@3.8

* **搜索引擎**: Elasticsearch\@8.0

* **缓存**: Redis\@7.0

* **文件存储**: MinIO对象存储

* **容器化**: Docker + Docker Compose

## 3. 路由定义

| 路由               | 用途                    |
| ---------------- | --------------------- |
| /                | 首页，显示系统概览、快速搜索和知识图谱导航 |
| /login           | 登录页面，用户身份验证           |
| /documents       | 文档管理页面，文档上传、分类和版本控制   |
| /search          | 搜索结果页面，全文检索结果展示和筛选    |
| /knowledge-graph | 知识图谱页面，交互式图谱可视化       |
| /profile         | 个人中心页面，用户信息和偏好设置      |
| /admin           | 系统管理页面，用户管理和系统监控      |
| /document/:id    | 文档详情页面，显示文档内容和元数据     |

## 4. API定义

### 4.1 核心API

**用户认证相关**

```
POST /api/auth/login
```

请求参数:

| 参数名      | 参数类型   | 是否必需 | 描述     |
| -------- | ------ | ---- | ------ |
| username | string | true | 用户名或邮箱 |
| password | string | true | 密码     |

响应参数:

| 参数名     | 参数类型    | 描述      |
| ------- | ------- | ------- |
| success | boolean | 登录是否成功  |
| token   | string  | JWT访问令牌 |
| user    | object  | 用户基本信息  |

示例:

```json
{
  "username": "admin@hktlora.com",
  "password": "123456"
}
```

**文档管理相关**

```
POST /api/documents/upload
```

请求参数:

| 参数名      | 参数类型   | 是否必需  | 描述      |
| -------- | ------ | ----- | ------- |
| file     | file   | true  | 上传的文档文件 |
| category | string | true  | 文档分类路径  |
| tags     | array  | false | 文档标签列表  |
| metadata | object | false | 文档元数据   |

**搜索相关**

```
GET /api/search
```

请求参数:

| 参数名      | 参数类型    | 是否必需  | 描述        |
| -------- | ------- | ----- | --------- |
| q        | string  | true  | 搜索关键词     |
| category | string  | false | 分类筛选      |
| page     | integer | false | 页码，默认1    |
| size     | integer | false | 每页大小，默认20 |

**知识图谱相关**

```
GET /api/knowledge-graph/nodes
```

请求参数:

| 参数名    | 参数类型    | 是否必需  | 描述       |
| ------ | ------- | ----- | -------- |
| type   | string  | false | 节点类型筛选   |
| depth  | integer | false | 图谱深度，默认2 |
| center | string  | false | 中心节点ID   |

## 5. 服务架构图

```mermaid
graph TD
    A[客户端/前端] --> B[API网关层]
    B --> C[业务服务层]
    C --> D[数据访问层]
    D --> E[(数据存储)]
    
    subgraph 服务端
        B
        C
        D
        F[缓存层]
        G[消息队列]
        H[文件处理服务]
        I[图计算服务]
    end
    
    C --> F
    C --> G
    C --> H
    C --> I
```

## 6. 数据模型

### 6.1 数据模型定义

```mermaid
erDiagram
    DOCUMENT ||--o{ DOCUMENT_VERSION : has
    DOCUMENT ||--o{ DOCUMENT_TAG : tagged
    DOCUMENT }|--|| CATEGORY : belongs_to
    USER ||--o{ DOCUMENT : creates
    USER ||--o{ USER_FAVORITE : favorites
    USER_FAVORITE }|--|| DOCUMENT : references
    
    DOCUMENT {
        UUID id PK
        string title
        string content_path
        UUID category_id FK
        UUID author_id FK
        timestamp created_at
        timestamp updated_at
        string status
        jsonb metadata
    }
    
    DOCUMENT_VERSION {
        UUID id PK
        UUID document_id FK
        string version_number
        string content_path
        text change_log
        timestamp created_at
    }
    
    CATEGORY {
        UUID id PK
        string name
        string path
        UUID parent_id FK
        integer sort_order
        jsonb permissions
    }
    
    USER {
        UUID id PK
        string username
        string email
        string password_hash
        string role
        timestamp created_at
        timestamp updated_at
    }
    
    TAG {
        UUID id PK
        string name
    }
    
    DOCUMENT_TAG {
        UUID document_id PK, FK
        UUID tag_id PK, FK
    }
    
    USER_FAVORITE {
        UUID user_id PK, FK
        UUID document_id PK, FK
    }
```

### 6.2 数据定义语言 (DDL)

**用户表 (users)**

```sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    username VARCHAR(100) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(50) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**分类表 (categories)**

```sql
CREATE TABLE categories (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) NOT NULL,
    path VARCHAR(255) UNIQUE NOT NULL,
    parent_id UUID REFERENCES categories(id),
    sort_order INTEGER DEFAULT 0,
    permissions JSONB
);
```

**文档表 (documents)**

```sql
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    title VARCHAR(255) NOT NULL,
    content_path VARCHAR(512) NOT NULL,
    category_id UUID REFERENCES categories(id),
    author_id UUID REFERENCES users(id),
    status VARCHAR(50) DEFAULT 'draft',
    metadata JSONB,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**文档版本表 (document\_versions)**

```sql
CREATE TABLE document_versions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    version_number VARCHAR(50) NOT NULL,
    content_path VARCHAR(512) NOT NULL,
    change_log TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**标签表 (tags)**

```sql
CREATE TABLE tags (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL
);
```

**文档标签关联表 (document\_tags)**

```sql
CREATE TABLE document_tags (
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    tag_id UUID REFERENCES tags(id) ON DELETE CASCADE,
    PRIMARY KEY (document_id, tag_id)
);
```

**用户收藏表 (user\_favorites)**

```sql
CREATE TABLE user_favorites (
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    document_id UUID REFERENCES documents(id) ON DELETE CASCADE,
    PRIMARY KEY (user_id, document_id)
);
```

## 7. 数据库协同工作方案

### 7.1 PostgreSQL与NebulaGraph协同架构

```mermaid
graph TD
    A[应用层] --> B[数据访问层]
    B --> C[PostgreSQL]
    B --> D[NebulaGraph]
    
    subgraph "PostgreSQL存储"
        C1[用户数据]
        C2[文档元数据]
        C3[分类信息]
        C4[版本历史]
    end
    
    subgraph "NebulaGraph存储"
        D1[文档关系]
        D2[知识图谱]
        D3[语义关联]
        D4[推荐关系]
    end
    
    C --> C1
    C --> C2
    C --> C3
    C --> C4
    
    D --> D1
    D --> D2
    D --> D3
    D --> D4
    
    E[数据同步服务] --> C
    E --> D
```

### 7.2 数据分工策略

**PostgreSQL负责：**

* 用户账户和权限管理

* 文档基础元数据（标题、作者、创建时间等）

* 分类层次结构

* 文档版本历史

* 系统配置和日志

**NebulaGraph负责：**

* 文档间的语义关联关系

* 基于目录结构的层次关系

* 用户行为产生的关联（浏览、收藏、引用）

* 知识图谱的可视化数据

* 推荐算法的关系数据

### 7.3 数据同步机制

```python
# 示例：文档创建时的双写操作
async def create_document(document_data):
    # 1. 写入PostgreSQL
    pg_result = await pg_client.create_document(document_data)
    
    # 2. 写入NebulaGraph
    nebula_result = await nebula_client.create_document_node(
        document_id=pg_result.id,
        category_path=document_data.category_path,
        metadata=document_data.metadata
    )
    
    # 3. 建立关系
    await nebula_client.create_category_relationship(
        document_id=pg_result.id,
        category_id=document_data.category_id
    )
    
    return pg_result
```

## 8. 部署架构配置

### 8.1 Docker Compose配置

```yaml
version: '3.8'

services:
  # PostgreSQL数据库
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: knowledge_base
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: 123456
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./scripts/init-db.sql:/docker-entrypoint-initdb.d/init-db.sql
    ports:
      - "5432:5432"
    networks:
      - kb_network

  # NebulaGraph图数据库
  nebula-metad:
    image: vesoft/nebula-metad:v3.8.0
    environment:
      USER: root
    command:
      - --meta_server_addrs=nebula-metad:9559
      - --local_ip=nebula-metad
      - --ws_ip=nebula-metad
      - --port=9559
    volumes:
      - nebula_meta:/data/meta
    networks:
      - kb_network

  nebula-storaged:
    image: vesoft/nebula-storaged:v3.8.0
    environment:
      USER: root
    command:
      - --meta_server_addrs=nebula-metad:9559
      - --local_ip=nebula-storaged
      - --ws_ip=nebula-storaged
      - --port=9779
    depends_on:
      - nebula-metad
    volumes:
      - nebula_storage:/data/storage
    networks:
      - kb_network

  nebula-graphd:
    image: vesoft/nebula-graphd:v3.8.0
    environment:
      USER: root
    command:
      - --meta_server_addrs=nebula-metad:9559
      - --port=9669
    depends_on:
      - nebula-metad
    ports:
      - "9669:9669"
    volumes:
      - nebula_logs:/logs
    networks:
      - kb_network

  # Elasticsearch搜索引擎
  elasticsearch:
    image: elasticsearch:8.0.0
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    volumes:
      - es_data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
    networks:
      - kb_network

  # Redis缓存
  redis:
    image: redis:7.0
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - kb_network

  # MinIO对象存储
  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: admin
      MINIO_ROOT_PASSWORD: 123456
    volumes:
      - minio_data:/data
    ports:
      - "9000:9000"
      - "9001:9001"
    networks:
      - kb_network

  # 后端API服务
  backend:
    build: ./src/backend
    environment:
      - DATABASE_URL=postgresql://admin:123456@postgres:5432/knowledge_base
      - NEBULA_HOST=nebula-graphd
      - NEBULA_PORT=9669
      - NEBULA_USER=admin
      - NEBULA_PASSWORD=123456
      - ELASTICSEARCH_URL=http://elasticsearch:9200
      - REDIS_URL=redis://redis:6379
      - MINIO_ENDPOINT=minio:9000
      - MINIO_ACCESS_KEY=admin
      - MINIO_SECRET_KEY=123456
    depends_on:
      - postgres
      - nebula-graphd
      - elasticsearch
      - redis
      - minio
    ports:
      - "8000:8000"
    networks:
      - kb_network

  # 前端应用
  frontend:
    build: ./src/frontend
    environment:
      - REACT_APP_API_URL=http://localhost:8000
    depends_on:
      - backend
    ports:
      - "3000:3000"
    networks:
      - kb_network

volumes:
  postgres_data:
  nebula_meta:
  nebula_storage:
  nebula_logs:
  es_data:
  redis_data:
  minio_data:

networks:
  kb_network:
    driver: bridge
```

### 8.2 数据库初始化脚本

```sql
-- scripts/init-db.sql
-- 创建扩展
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- 创建索引
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_role ON users(role);
CREATE INDEX idx_documents_category ON documents(category_id);
CREATE INDEX idx_documents_author ON documents(author_id);
CREATE INDEX idx_documents_status ON documents(status);
CREATE INDEX idx_documents_title_gin ON documents USING gin(to_tsvector('chinese', title));
CREATE INDEX idx_categories_parent ON categories(parent_id);
CREATE INDEX idx_categories_path ON categories(path);

-- 插入初始数据
INSERT INTO users (username, email, password_hash, role) VALUES
('admin', 'admin@hktloar.com', '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj3L3jzjvQm6', 'admin'),
('manager', 'manager@hktloar.com', '$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/LewdBPj3L3jzjvQm6', 'manager');

INSERT INTO categories (name, path, parent_id) VALUES
('公司基本信息', '/01_公司基本信息', NULL),
('人力资源中心', '/02_人力资源中心', NULL),
('财务管理中心', '/03_财务管理中心', NULL);
```

## 9. 性能优化策略

### 9.1 PostgreSQL优化

```sql
-- 配置优化参数
ALTER SYSTEM SET shared_buffers = '256MB';
ALTER SYSTEM SET effective_cache_size = '1GB';
ALTER SYSTEM SET maintenance_work_mem = '64MB';
ALTER SYSTEM SET checkpoint_completion_target = 0.9;
ALTER SYSTEM SET wal_buffers = '16MB';
ALTER SYSTEM SET default_statistics_target = 100;
SELECT pg_reload_conf();
```

### 9.2 连接池配置

```python
# SQLAlchemy连接池配置
from sqlalchemy import create_engine
from sqlalchemy.pool import QueuePool

engine = create_engine(
    DATABASE_URL,
    poolclass=QueuePool,
    pool_size=20,
    max_overflow=30,
    pool_pre_ping=True,
    pool_recycle=3600
)
```

