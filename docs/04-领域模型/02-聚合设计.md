# 聚合设计

## 文档信息
- **文档版本**: v1.0
- **创建日期**: 2024-01-15
- **最后更新**: 2024-01-15
- **负责人**: 架构师
- **审核人**: 领域专家

## 聚合设计原则

### DDD聚合设计原则
1. **一致性边界**: 聚合内部保持强一致性，聚合间保持最终一致性
2. **事务边界**: 一个事务只能修改一个聚合实例
3. **引用规则**: 聚合间通过ID引用，不直接持有对象引用
4. **大小适中**: 聚合应该尽可能小，只包含必要的实体和值对象
5. **业务不变量**: 聚合负责维护重要的业务不变量

## 核心聚合设计

### 1. 知识聚合 (KnowledgeAggregate)

#### 聚合根: Knowledge
```typescript
class KnowledgeAggregate {
    // 聚合根标识
    private readonly id: KnowledgeId;
    
    // 基本属性
    private title: KnowledgeTitle;
    private content: KnowledgeContent;
    private status: KnowledgeStatus;
    private authorId: UserId;
    private categoryId: CategoryId;
    
    // 聚合内实体
    private tags: Set<Tag>;
    private attachments: List<Attachment>;
    private versions: List<KnowledgeVersion>;
    
    // 元数据
    private readonly createdAt: DateTime;
    private updatedAt: DateTime;
    private publishedAt?: DateTime;
    
    // 业务方法
    public publish(publisherId: UserId): void {
        this.validatePublishPermission(publisherId);
        this.validateContentCompleteness();
        
        this.status = KnowledgeStatus.published();
        this.publishedAt = DateTime.now();
        this.updatedAt = DateTime.now();
        
        // 发布领域事件
        this.addDomainEvent(new KnowledgePublished(
            this.id, publisherId, DateTime.now()
        ));
    }
    
    public updateContent(
        content: KnowledgeContent, 
        editorId: UserId
    ): void {
        this.validateEditPermission(editorId);
        
        // 创建新版本
        const newVersion = new KnowledgeVersion(
            this.content, 
            this.updatedAt, 
            editorId
        );
        this.versions.add(newVersion);
        
        // 更新内容
        this.content = content;
        this.updatedAt = DateTime.now();
        
        // 如果已发布，需要重新审核
        if (this.status.isPublished()) {
            this.status = KnowledgeStatus.pendingReview();
        }
        
        this.addDomainEvent(new KnowledgeUpdated(
            this.id, editorId, DateTime.now(), content
        ));
    }
    
    public addTag(tag: Tag): void {
        this.validateTagLimit();
        this.tags.add(tag);
        this.updatedAt = DateTime.now();
    }
    
    public removeTag(tag: Tag): void {
        this.tags.remove(tag);
        this.updatedAt = DateTime.now();
    }
    
    public archive(archiverId: UserId): void {
        this.validateArchivePermission(archiverId);
        this.status = KnowledgeStatus.archived();
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new KnowledgeArchived(
            this.id, archiverId, DateTime.now()
        ));
    }
    
    // 业务不变量验证
    private validatePublishPermission(publisherId: UserId): void {
        if (!this.authorId.equals(publisherId) && 
            !this.hasPublishPermission(publisherId)) {
            throw new DomainException("无权限发布此知识条目");
        }
    }
    
    private validateContentCompleteness(): void {
        if (this.title.isEmpty() || this.content.isEmpty()) {
            throw new DomainException("标题和内容不能为空");
        }
        
        if (this.categoryId == null) {
            throw new DomainException("必须指定知识分类");
        }
    }
    
    private validateTagLimit(): void {
        if (this.tags.size() >= 10) {
            throw new DomainException("标签数量不能超过10个");
        }
    }
}
```

#### 聚合内实体和值对象

```typescript
// 值对象: 知识标识
class KnowledgeId {
    private readonly value: string;
    
    constructor(value: string) {
        if (!this.isValidId(value)) {
            throw new DomainException("无效的知识ID");
        }
        this.value = value;
    }
    
    public equals(other: KnowledgeId): boolean {
        return this.value === other.value;
    }
    
    private isValidId(value: string): boolean {
        return value != null && value.length > 0;
    }
}

// 值对象: 知识标题
class KnowledgeTitle {
    private readonly value: string;
    
    constructor(value: string) {
        this.validateTitle(value);
        this.value = value.trim();
    }
    
    public isEmpty(): boolean {
        return this.value.length === 0;
    }
    
    private validateTitle(value: string): void {
        if (value == null || value.trim().length === 0) {
            throw new DomainException("标题不能为空");
        }
        
        if (value.length > 200) {
            throw new DomainException("标题长度不能超过200字符");
        }
    }
}

// 值对象: 知识内容
class KnowledgeContent {
    private readonly markdown: string;
    private readonly html: string;
    private readonly attachments: List<Attachment>;
    
    constructor(markdown: string, attachments: List<Attachment> = []) {
        this.validateContent(markdown);
        this.markdown = markdown;
        this.html = this.convertToHtml(markdown);
        this.attachments = attachments;
    }
    
    public isEmpty(): boolean {
        return this.markdown.trim().length === 0;
    }
    
    public getWordCount(): number {
        return this.markdown.split(/\s+/).length;
    }
    
    public extractKeywords(): List<string> {
        // 实现关键词提取逻辑
        return [];
    }
    
    private validateContent(markdown: string): void {
        if (markdown == null) {
            throw new DomainException("内容不能为null");
        }
        
        if (markdown.length > 100000) {
            throw new DomainException("内容长度不能超过100000字符");
        }
    }
    
    private convertToHtml(markdown: string): string {
        // 实现Markdown到HTML的转换
        return markdown;
    }
}

// 值对象: 知识状态
class KnowledgeStatus {
    private readonly type: StatusType;
    private readonly timestamp: DateTime;
    private readonly reason?: string;
    
    private constructor(
        type: StatusType, 
        timestamp: DateTime, 
        reason?: string
    ) {
        this.type = type;
        this.timestamp = timestamp;
        this.reason = reason;
    }
    
    public static draft(): KnowledgeStatus {
        return new KnowledgeStatus(StatusType.DRAFT, DateTime.now());
    }
    
    public static pendingReview(): KnowledgeStatus {
        return new KnowledgeStatus(StatusType.PENDING_REVIEW, DateTime.now());
    }
    
    public static published(): KnowledgeStatus {
        return new KnowledgeStatus(StatusType.PUBLISHED, DateTime.now());
    }
    
    public static archived(reason?: string): KnowledgeStatus {
        return new KnowledgeStatus(StatusType.ARCHIVED, DateTime.now(), reason);
    }
    
    public isDraft(): boolean {
        return this.type === StatusType.DRAFT;
    }
    
    public isPublished(): boolean {
        return this.type === StatusType.PUBLISHED;
    }
    
    public isArchived(): boolean {
        return this.type === StatusType.ARCHIVED;
    }
}

// 实体: 知识版本
class KnowledgeVersion {
    private readonly id: VersionId;
    private readonly content: KnowledgeContent;
    private readonly createdAt: DateTime;
    private readonly createdBy: UserId;
    private readonly changeDescription?: string;
    
    constructor(
        content: KnowledgeContent,
        createdAt: DateTime,
        createdBy: UserId,
        changeDescription?: string
    ) {
        this.id = VersionId.generate();
        this.content = content;
        this.createdAt = createdAt;
        this.createdBy = createdBy;
        this.changeDescription = changeDescription;
    }
    
    public getContentDiff(other: KnowledgeVersion): ContentDiff {
        // 实现内容差异比较
        return new ContentDiff(this.content, other.content);
    }
}
```

### 2. 用户聚合 (UserAggregate)

#### 聚合根: User
```typescript
class UserAggregate {
    private readonly id: UserId;
    private profile: UserProfile;
    private preferences: UserPreferences;
    private roles: Set<Role>;
    private status: UserStatus;
    private readonly createdAt: DateTime;
    private updatedAt: DateTime;
    private lastLoginAt?: DateTime;
    
    // 聚合内实体
    private skills: List<UserSkill>;
    private interests: List<UserInterest>;
    
    public updateProfile(newProfile: UserProfile): void {
        this.validateProfileUpdate(newProfile);
        
        const oldProfile = this.profile;
        this.profile = newProfile;
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new UserProfileUpdated(
            this.id, oldProfile, newProfile, DateTime.now()
        ));
    }
    
    public addRole(role: Role): void {
        this.validateRoleAddition(role);
        this.roles.add(role);
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new UserRoleAdded(
            this.id, role, DateTime.now()
        ));
    }
    
    public removeRole(role: Role): void {
        this.validateRoleRemoval(role);
        this.roles.remove(role);
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new UserRoleRemoved(
            this.id, role, DateTime.now()
        ));
    }
    
    public hasPermission(permission: Permission): boolean {
        return this.roles.stream()
            .anyMatch(role -> role.hasPermission(permission));
    }
    
    public updateSkills(skills: List<UserSkill>): void {
        this.skills = skills;
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new UserSkillsUpdated(
            this.id, skills, DateTime.now()
        ));
    }
    
    public recordLogin(): void {
        this.lastLoginAt = DateTime.now();
        
        this.addDomainEvent(new UserLoggedIn(
            this.id, DateTime.now()
        ));
    }
    
    public activate(): void {
        if (this.status.isActive()) {
            throw new DomainException("用户已经是激活状态");
        }
        
        this.status = UserStatus.active();
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new UserActivated(
            this.id, DateTime.now()
        ));
    }
    
    public deactivate(reason: string): void {
        if (!this.status.isActive()) {
            throw new DomainException("用户不是激活状态");
        }
        
        this.status = UserStatus.inactive(reason);
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new UserDeactivated(
            this.id, reason, DateTime.now()
        ));
    }
    
    // 业务不变量验证
    private validateProfileUpdate(profile: UserProfile): void {
        if (profile.getEmail().isEmpty()) {
            throw new DomainException("邮箱不能为空");
        }
        
        if (profile.getUsername().isEmpty()) {
            throw new DomainException("用户名不能为空");
        }
    }
    
    private validateRoleAddition(role: Role): void {
        if (this.roles.contains(role)) {
            throw new DomainException("用户已拥有该角色");
        }
        
        if (this.roles.size() >= 5) {
            throw new DomainException("用户角色数量不能超过5个");
        }
    }
    
    private validateRoleRemoval(role: Role): void {
        if (!this.roles.contains(role)) {
            throw new DomainException("用户没有该角色");
        }
        
        if (this.roles.size() <= 1) {
            throw new DomainException("用户至少需要一个角色");
        }
    }
}
```

### 3. 分类聚合 (CategoryAggregate)

#### 聚合根: Category
```typescript
class CategoryAggregate {
    private readonly id: CategoryId;
    private name: CategoryName;
    private description: string;
    private parentId?: CategoryId;
    private readonly createdAt: DateTime;
    private updatedAt: DateTime;
    
    // 聚合内实体
    private children: List<Category>;
    private metadata: CategoryMetadata;
    
    public addChild(child: Category): void {
        this.validateChildAddition(child);
        
        child.setParent(this.id);
        this.children.add(child);
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new CategoryChildAdded(
            this.id, child.getId(), DateTime.now()
        ));
    }
    
    public removeChild(childId: CategoryId): void {
        const child = this.findChild(childId);
        if (child == null) {
            throw new DomainException("子分类不存在");
        }
        
        this.validateChildRemoval(child);
        
        child.setParent(null);
        this.children.remove(child);
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new CategoryChildRemoved(
            this.id, childId, DateTime.now()
        ));
    }
    
    public moveTo(newParentId: CategoryId): void {
        this.validateMove(newParentId);
        
        const oldParentId = this.parentId;
        this.parentId = newParentId;
        this.updatedAt = DateTime.now();
        
        this.addDomainEvent(new CategoryMoved(
            this.id, oldParentId, newParentId, DateTime.now()
        ));
    }
    
    public getPath(): List<CategoryId> {
        // 实现获取分类路径的逻辑
        return [];
    }
    
    public getDepth(): int {
        // 实现获取分类深度的逻辑
        return 0;
    }
    
    // 业务不变量验证
    private validateChildAddition(child: Category): void {
        if (this.children.size() >= 20) {
            throw new DomainException("子分类数量不能超过20个");
        }
        
        if (this.getDepth() >= 5) {
            throw new DomainException("分类层级不能超过5级");
        }
        
        if (this.hasChild(child.getId())) {
            throw new DomainException("子分类已存在");
        }
    }
    
    private validateChildRemoval(child: Category): void {
        if (child.hasChildren()) {
            throw new DomainException("不能删除有子分类的分类");
        }
        
        if (child.hasKnowledge()) {
            throw new DomainException("不能删除有知识条目的分类");
        }
    }
    
    private validateMove(newParentId: CategoryId): void {
        if (this.id.equals(newParentId)) {
            throw new DomainException("不能将分类移动到自己下面");
        }
        
        if (this.isAncestorOf(newParentId)) {
            throw new DomainException("不能将分类移动到自己的子分类下面");
        }
    }
}
```

## 聚合间协作模式

### 1. 事件驱动协作

```typescript
// 知识发布后，更新搜索索引
@EventHandler
class KnowledgePublishedHandler {
    constructor(
        private searchService: SearchService,
        private recommendationService: RecommendationService
    ) {}
    
    public async handle(event: KnowledgePublished): Promise<void> {
        // 更新搜索索引
        await this.searchService.indexKnowledge(event.knowledgeId);
        
        // 更新推荐系统
        await this.recommendationService.updateKnowledgeGraph(
            event.knowledgeId
        );
    }
}

// 用户行为记录后，更新推荐模型
@EventHandler
class UserBehaviorRecordedHandler {
    constructor(
        private recommendationService: RecommendationService
    ) {}
    
    public async handle(event: UserBehaviorRecorded): Promise<void> {
        await this.recommendationService.updateUserProfile(
            event.userId, 
            event.behaviorType, 
            event.target
        );
    }
}
```

### 2. 应用服务协调

```typescript
@ApplicationService
class KnowledgeApplicationService {
    constructor(
        private knowledgeRepository: KnowledgeRepository,
        private userRepository: UserRepository,
        private categoryRepository: CategoryRepository,
        private eventBus: EventBus
    ) {}
    
    @Transactional
    public async createKnowledge(
        command: CreateKnowledgeCommand
    ): Promise<KnowledgeId> {
        // 验证用户权限
        const author = await this.userRepository.findById(command.authorId);
        if (!author.hasPermission(Permission.CREATE_KNOWLEDGE)) {
            throw new ApplicationException("用户无权限创建知识");
        }
        
        // 验证分类存在
        const category = await this.categoryRepository.findById(
            command.categoryId
        );
        if (category == null) {
            throw new ApplicationException("分类不存在");
        }
        
        // 创建知识聚合
        const knowledge = KnowledgeAggregate.create(
            command.title,
            command.content,
            command.authorId,
            command.categoryId,
            command.tags
        );
        
        // 保存聚合
        await this.knowledgeRepository.save(knowledge);
        
        // 发布领域事件
        await this.eventBus.publishAll(knowledge.getDomainEvents());
        
        return knowledge.getId();
    }
    
    @Transactional
    public async publishKnowledge(
        command: PublishKnowledgeCommand
    ): Promise<void> {
        // 加载知识聚合
        const knowledge = await this.knowledgeRepository.findById(
            command.knowledgeId
        );
        if (knowledge == null) {
            throw new ApplicationException("知识不存在");
        }
        
        // 执行业务操作
        knowledge.publish(command.publisherId);
        
        // 保存聚合
        await this.knowledgeRepository.save(knowledge);
        
        // 发布领域事件
        await this.eventBus.publishAll(knowledge.getDomainEvents());
    }
}
```

## 聚合持久化策略

### 1. 事件溯源模式

```typescript
// 知识聚合的事件存储
class KnowledgeEventStore {
    public async saveEvents(
        aggregateId: KnowledgeId,
        events: List<DomainEvent>,
        expectedVersion: number
    ): Promise<void> {
        // 实现事件存储逻辑
    }
    
    public async getEvents(
        aggregateId: KnowledgeId,
        fromVersion?: number
    ): Promise<List<DomainEvent>> {
        // 实现事件加载逻辑
        return [];
    }
}

// 聚合重建
class KnowledgeAggregateFactory {
    public static fromEvents(
        events: List<DomainEvent>
    ): KnowledgeAggregate {
        const aggregate = new KnowledgeAggregate();
        
        events.forEach(event => {
            aggregate.apply(event);
        });
        
        return aggregate;
    }
}
```

### 2. 快照模式

```typescript
// 聚合快照
class KnowledgeSnapshot {
    public readonly aggregateId: KnowledgeId;
    public readonly version: number;
    public readonly data: KnowledgeData;
    public readonly timestamp: DateTime;
    
    constructor(aggregate: KnowledgeAggregate) {
        this.aggregateId = aggregate.getId();
        this.version = aggregate.getVersion();
        this.data = aggregate.toData();
        this.timestamp = DateTime.now();
    }
}

// 快照存储
class KnowledgeSnapshotStore {
    public async saveSnapshot(
        snapshot: KnowledgeSnapshot
    ): Promise<void> {
        // 实现快照保存逻辑
    }
    
    public async getSnapshot(
        aggregateId: KnowledgeId
    ): Promise<KnowledgeSnapshot | null> {
        // 实现快照加载逻辑
        return null;
    }
}
```

## 聚合性能优化

### 1. 延迟加载

```typescript
class KnowledgeAggregate {
    private versions: LazyList<KnowledgeVersion>;
    private attachments: LazyList<Attachment>;
    
    public getVersions(): List<KnowledgeVersion> {
        return this.versions.load();
    }
    
    public getAttachments(): List<Attachment> {
        return this.attachments.load();
    }
}
```

### 2. 聚合分割

```typescript
// 将大聚合分割为多个小聚合
class KnowledgeBasicAggregate {
    // 只包含基本信息
    private id: KnowledgeId;
    private title: KnowledgeTitle;
    private content: KnowledgeContent;
    private status: KnowledgeStatus;
}

class KnowledgeMetadataAggregate {
    // 包含元数据信息
    private knowledgeId: KnowledgeId;
    private tags: Set<Tag>;
    private statistics: KnowledgeStatistics;
    private relations: List<KnowledgeRelation>;
}
```

## 版本历史

| 版本 | 日期 | 修改内容 | 修改人 |
|------|------|----------|--------|
| v1.0 | 2024-01-15 | 初始版本，定义核心聚合设计 | 架构师 |

## 审核记录

| 审核人 | 审核日期 | 审核意见 | 状态 |
|--------|----------|----------|------|
| 领域专家 | 2024-01-15 | 聚合设计符合DDD原则，边界清晰 | 通过 |
| 技术负责人 | 2024-01-15 | 实现方案可行，性能考虑充分 | 通过 |